PAGINATION 

means converting large amount of data into smaller data display




## üîç Difference between Previous and New `getAll()`:

| Feature              | **Previous `getAll()`** (Without Pagination) | **New `getAll()`** (With Pagination)                                     |
| -------------------- | -------------------------------------------- | ------------------------------------------------------------------------ |
| **Return type**      | `List<Restaurant>`                           | `Page<Restaurant>`                                                       |
| **Data returned**    | All restaurants at once                      | A subset (a page) of restaurants                                         |
| **Scalability**      | Poor for large datasets (slow, memory-heavy) | Efficient for large datasets                                             |
| **Extra metadata**   | ‚ùå No metadata                                | ‚úÖ Includes metadata like `totalPages`, `pageNumber`, `size`, etc.        |
| **Query Parameters** | No control over amount or order of data      | Can pass `page`, `size`, `sortBy`                                        |
| **Use case**         | Good for small datasets                      | Best for APIs needing page-wise fetch (e.g., UI tables, infinite scroll) |

---

### ‚úÖ Example Controller with Pagination Support

To make the best use of the `Page<Restaurant>` in your controller:

```java
@GetMapping("/getall")
public ResponseEntity<ResponseStructure<Page<Restaurant>>> getAllRestaurant(
    @RequestParam(defaultValue = "0") int page,
    @RequestParam(defaultValue = "5") int size,
    @RequestParam(defaultValue = "id") String sortBy
) {
    Page<Restaurant> restaurantPage = restaurantService.getAll(page, size, sortBy);
    ResponseStructure<Page<Restaurant>> response = new ResponseStructure<>();
    response.setData(restaurantPage);
    response.setMessage("All restaurants retrieved successfully");
    response.setStatusCode(HttpStatus.OK.value());
    return new ResponseEntity<>(response, HttpStatus.OK);
}
```

---

### ‚úÖ How to Call It from Postman

Use a **GET** request like:

```
GET http://localhost:8080/restaurant/api/getall?page=0&size=5&sortBy=name
```

You can change:

* `page=1` ‚Üí to fetch the second page
* `size=10` ‚Üí to get 10 restaurants per page
* `sortBy=name` ‚Üí to sort by restaurant name

---

### ‚úÖ Summary

The **main difference** is that now your API supports **pagination, sorting, and scalability** ‚Äî making it production-ready for larger datasets. The output you showed proves it's working perfectly. Let me know if you also want to **support ascending/descending sorting** using a flag like `direction=asc`.





=============================================================================================================================================================================================================================================================================================================================
fo the UPDATE RESTAURANT 

Great! To implement an **`updateRestaurant`** method in your REST API, you‚Äôll need to update both:

1. ‚úÖ The **Service layer** (`RestaurantService` and `RestaurantServiceImplementation`)
2. ‚úÖ The **Controller** (`RestaurantController`)

---

## ‚úÖ 1. Add Method in `RestaurantService` Interface

```java
Restaurant updateRestaurant(Integer id, Restaurant restaurant);
```

---

## ‚úÖ 2. Implement in `RestaurantServiceImplementation`

```java
@Override
public Restaurant updateRestaurant(Integer id, Restaurant updatedRestaurant) {
    Restaurant existingRestaurant = restaurantRepository.findById(id)
        .orElseThrow(() -> new NoSuchElementException("Restaurant with ID " + id + " not found"));

    // Update only the relevant fields
    existingRestaurant.setName(updatedRestaurant.getName());
    existingRestaurant.setLocation(updatedRestaurant.getLocation());
    existingRestaurant.setCity(updatedRestaurant.getCity());
    existingRestaurant.setState(updatedRestaurant.getState());
    existingRestaurant.setCountry(updatedRestaurant.getCountry());
    existingRestaurant.setPincode(updatedRestaurant.getPincode());
    existingRestaurant.setUpdateAt(java.time.LocalDateTime.now());

    return restaurantRepository.save(existingRestaurant);
}
```

---

## ‚úÖ 3. Add Controller Method in `RestaurantController`

```java
@PutMapping("/update/{id}")
public ResponseEntity<ResponseStructure<Restaurant>> updateRestaurant(
        @PathVariable Integer id,
        @RequestBody Restaurant restaurant) {

    Restaurant updatedRestaurant = restaurantService.updateRestaurant(id, restaurant);

    ResponseStructure<Restaurant> response = new ResponseStructure<>();
    response.setStatusCode(HttpStatus.OK.value());
    response.setMessage("Restaurant updated successfully");
    response.setData(updatedRestaurant);

    return new ResponseEntity<>(response, HttpStatus.OK);
}
```

---

## ‚úÖ Example JSON to send via Postman (PUT)

**URL**:

```
PUT http://localhost:8080/restaurant/api/update/6
```

**Body (raw JSON):**

```json
{
    "name": "New Restaurant Name",
    "location": "new area",
    "city": "new city",
    "state": "new state",
    "country": "India",
    "pincode": 123456
}
```

> üìå Make sure the restaurant with ID `6` exists in your database before updating it.

---

## ‚úÖ Summary of Changes

| Layer                             | Change                                                                    |
| --------------------------------- | ------------------------------------------------------------------------- |
| `RestaurantService`               | Add `updateRestaurant(id, restaurant)` method signature                   |
| `RestaurantServiceImplementation` | Implement the update logic using `findById`, update fields, then `save()` |
| `RestaurantController`            | Add a `@PutMapping("/update/{id}")` endpoint                              |

Let me know if you want **partial update (PATCH)** support or to prevent updating certain fields like `createdAt`.
